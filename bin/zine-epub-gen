#!/usr/bin/env node

'use strict';

const fs = require("fs");
const path = require("path");
const imgSize = require("image-size");
const Epub = require("epub-gen");
const cheerio = require("cheerio");
const co = require("co");
const _request = require('request');
const request = require("co-request");
const argv = require('optimist').argv;
const outputPath = argv['o'];
const lang = argv['l'] || 'zh-cn';

const i18n = {
	"zh-cn": {
		"cover": "封面",
		"head_page": "扉页",
		"copyright_info": "版权信息",
		"copyright_page": "版权页",
		"author_page": "作者页",
		"wrote": "[著]",
		"wrote_1": " 著",
		"publish_by_zine": "通过自出版平台 Zine 发布",
		"author_column": "作者专栏地址：",
		"copyright": "该作品由作者通过 Zine 制作发布, 版权归作者所有。<br>未经书面同意,不得以任何形式复制转载。",
		"colon": "：",
		"comma": "，",
		"text_author": "作  者",
		"text_word_count": "字  数",
		"text_publisher": "出版方",
		"wechat_scan": "微信扫码在小程序上查看本书",
		"unknown": "未知"
	},
	"zh-tw": {
		"cover": "封面",
		"head_page": "扉頁",
		"copyright_info": "版權信息",
		"copyright_page": "版權頁",
		"author_page": "作者页",
		"wrote": "[著]",
		"wrote_1": " 著",
		"publish_by_zine": "通過自出版平台 Zine 發布",
		"author_column": "作者專欄地址：",
		"copyright": "該作品由作者通過 Zine 制作發布, 版權歸作者所有。<br>未經書面同意,不得以任何形式複制轉載。",
		"colon": "：",
		"comma": "，",
		"text_author": "作  者",
		"text_word_count": "字  數",
		"text_publisher": "出版方",
		"wechat_scan": "微信掃碼在小程序上查看本書",
		"unknown": "未知"
	},
	"en": {
		"cover": "Cover",
		"head_page": "Head Page",
		"copyright_info": "Copyright Information",
		"copyright_page": "Copyright Page",
		"author_page": "Author Page",
		"wrote": "",
		"wrote_1": "",
		"publish_by_zine": "Released by publishing platform Zine",
		"author_column": "Author's column link:",
		"copyright": "The work is published by the author through Zine, and the copyright belongs to the author. <br> no copy can be copied in any form without written consent.",
		"colon": ":",
		"comma": ",",
		"text_author": "Author    ",
		"text_word_count": "Word count",
		"text_publisher": "Publisher ",
		"wechat_scan": "Scan in Wechat to see this book in mini-program",
		"unknown": "Unknown"
	}
};

const tempFilePath = path.join(__dirname, '../temp/' + UUID({ noDash: true }) + '/');
fs.mkdirSync(tempFilePath);

const TOCTemplatePath = path.join(__dirname, '../lib/pages/TOC/toc.xhtml.ejs');
const coverPageTPL = fs.readFileSync(path.join(__dirname, '../lib/pages/cover-page/cover-page.tpl'));
const coverPageCSS = fs.readFileSync(path.join(__dirname, '../lib/pages/cover-page/cover-page.css'));
const headPageTPL = fs.readFileSync(path.join(__dirname, '../lib/pages/head-page/head-page.tpl'));
const headPageCSS = fs.readFileSync(path.join(__dirname, '../lib/pages/head-page/head-page.css'));
const copyrightPageTPL = fs.readFileSync(path.join(__dirname, '../lib/pages/copyright-page/copyright-page.tpl'));
const copyrightPageCSS = fs.readFileSync(path.join(__dirname, '../lib/pages/copyright-page/copyright-page.css'));
const authorPageTPL = fs.readFileSync(path.join(__dirname, '../lib/pages/author-page/author-page.tpl'));
const authorPageCSS = fs.readFileSync(path.join(__dirname, '../lib/pages/author-page/author-page.css'));


let stdinData = '';
let inputData;
process.stdin.setEncoding('utf-8');
process.stdin.on('readable', function () {
	let chunk;
	while (chunk = this.read()) {
		stdinData += chunk.toString();
	}
});
process.stdin.on('end', function () {
	try {
		inputData = JSON.parse(stdinData);
	} catch (e) {
		console.log(e.stack)
	}
	if (!inputData) {
		console.log('Error: invalid input data!');
		process.exit(1);
		return;
	}
	co(function* () {
		const { slug, owner, name, heading, description, cover, fonts, word_count, wx_mini_program_qr_code } = inputData;

		const job = {
			fonts: {
				css: '',
				src: [],
				job: []
			},
			contentCSS: requestBody('https://zine.la/p/c/article/Content/Content_fb058ab.css'),
			contentList: []
		};

		for (let i in fonts) {
			const matches = fonts[i].src.match(/\.([^.]+?)$/);
			const extName = matches && matches[1];
			if (extName) {
				job.fonts.css += '@font-face{font-family:' + fonts[i].font_family +';src:url(./fonts/font_' + i + '.' + extName + ')}';
				job.fonts.job[i] = requestPipeToFile(fonts[i].src, tempFilePath + 'font_' + i + '.' + extName);
				job.fonts.src[i] = tempFilePath + 'font_' + i + '.' + extName;
			}
		}

		function loopList (list, depth, target) {
			let indentSpaceStr = '';
			for (let i = 0; i < depth; i ++) {
				indentSpaceStr += '——';
			}
			list.forEach((item, index) => {
				const identity = depth + '-' + index;
				item.detail = item.detail || {};
				const title = item.detail.name || item.detail.title;
				const background = item.detail.background || {};
				target.push({
					title: indentSpaceStr + '  ' + title,
					backgroundCSS: requestBackgroundCSS(background, identity),
					contentAndTheme: requestThemeCSS(title, item.detail.content, item.detail.theme && item.detail.theme.css, identity)
				});

				if (item.children) {
					loopList(item.children, depth + 1, target);
				}
			});
		}

		loopList(inputData.children, 0, job.contentList);

		const result = yield job;

		const date = new Date();
		const coverPageContent = coverPageTPL.toString()
			.replace(/\{\{\scover\s\}\}/g, cover);
		const headPageContent = headPageTPL.toString()
			.replace(/\{\{\stitle\s\}\}/g, name)
			.replace(/\{\{\sheading\s\}\}/g, heading || '')
			.replace(/\{\{\sauthor\s\}\}/g, owner.username)
			.replace(/\{\{\swrote\s\}\}/g, i18n[lang].wrote)
			.replace(/\{\{\sdescription\s\}\}/g, description);
		const copyrightPageContent = copyrightPageTPL.toString()
			.replace(/\{\{\swrote\s\}\}/g, i18n[lang].wrote_1)
			.replace(/\{\{\scopyright_info\s\}\}/g, i18n[lang].copyright_info)
			.replace(/\{\{\spublish_by_zine\s\}\}/g, i18n[lang].publish_by_zine)
			.replace(/\{\{\syear_date\s\}\}/g, date.getFullYear() + '.' + (date.getMonth() + 1) + '.' + date.getDate())
			.replace(/\{\{\sauthor_column\s\}\}/g, i18n[lang].author_column)
			.replace(/\{\{\scolumn_link\s\}\}/g, owner.column_url)
			.replace(/\{\{\stitle\s\}\}/g, name)
			.replace(/\{\{\sauthor\s\}\}/g, owner.username)
			.replace(/\{\{\sword_count\s\}\}/g, word_count || i18n[lang].unknown)
			.replace(/\{\{\scopyright\s\}\}/g, i18n[lang].copyright)
			.replace(/\{\{\scolon\s\}\}/g, i18n[lang].colon)
			.replace(/\{\{\scomma\s\}\}/g, i18n[lang].comma)
			.replace(/\{\{\stext_author\s\}\}/g, i18n[lang].text_author)
			.replace(/\{\{\stext_word_count\s\}\}/g, i18n[lang].text_word_count)
			.replace(/\{\{\stext_publisher\s\}\}/g, i18n[lang].text_publisher);
		const authorPageContent = authorPageTPL.toString()
			.replace(/\{\{\sauthor\s\}\}/g, owner.username)
			.replace(/\{\{\sdescription\s\}\}/g, owner.description || '')
			.replace(/\{\{\sqr_code_url\s\}\}/g, wx_mini_program_qr_code)
			.replace(/\{\{\swechat_scan\s\}\}/g, i18n[lang].wechat_scan);

		const option = {
		  title: name,
		  author: owner.username,
		  cover: cover,
		  tocTitle: name,
		  lang,
		  appendChapterTitles: false,
		  customHtmlTocTemplatePath: TOCTemplatePath,
		  content: [
		  	{ title: i18n[lang].cover, data: coverPageContent, beforeToc: true },
		  	{ title: i18n[lang].head_page, data: headPageContent, beforeToc: true },
		  	{ title: i18n[lang].copyright_page, data: copyrightPageContent, beforeToc: true },
		  	{ title: i18n[lang].author_page, data: authorPageContent, beforeToc: true }
		  ],
		  fonts: result.fonts.src,
		  css: coverPageCSS + headPageCSS + copyrightPageCSS + authorPageCSS + result.fonts.css + result.contentCSS
		};

		result.contentList.forEach((item) => {
			option.content.push({
				title: (item.title || '').substr(0, 50),
				data: item.contentAndTheme.content
			});

			option.css += item.contentAndTheme.css + item.backgroundCSS
		});


		// console.log(JSON.stringify(option));
		new Epub(option, outputPath).promise.then(function () {
			deleteFolderRecursive(tempFilePath);
		}, function () {
			deleteFolderRecursive(tempFilePath);
		});
	});
});

function * requestBody(url) {
	const response = yield request(url);
	return response.body;
}
function * requestThemeCSS(title, content, cssURL, identity) {
	let response;
	if (cssURL) {
		response = yield request(cssURL);
	}
	if (content) {
	    const $ = cheerio.load(content, { decodeEntities: false });
	    $('font').each((i, item) => {
	    	$(item).css('color', $(item).attr('color'));
	    	$(item).removeAttr('color');
	    });
	    content = $.html()
	}
	return {
		content: '<div class="content content-' + identity + '">' + (content || title) + '</div>',
		css: cssURL && response.body.replace(/\.content\b/g, '.content-' + identity)
	}
}
function * requestBackgroundCSS(backgroundData, identity) {
	const { type, value } = backgroundData;
	const matches = value && value.match(/\.([^.]+?)$/);
	const extName = matches && matches[1];
	let filePath = tempFilePath + 'img_temp_' + (new Date().getTime()) + '.' + extName;

	if (type === 'texture') {
		yield requestPipeToFile(value, filePath);
		const dimens = imgSize(filePath);
		return '.content-' + identity + '{background-image:url(' + value + ');background-size:' + (dimens.width / 2) + 'px ' + (dimens.height / 2) + 'px}';
	}
	else if (type === 'color') {
		return '.content-' + identity + '{background-color:' + value + '}';
	}
}
function requestPipeToFile(url, filepath) {
    return new Promise(function(resolve, reject) {
        try {
            const stream = fs.createWriteStream(filepath);
            stream.on('finish', function() {
                // console.log("pipe finish:", url);
                return resolve(true);
            });
            return _request(url).pipe(stream);
        } catch (e) {
            return reject(e);
        }
    });
};
function deleteFolderRecursive(path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function(file) {
            var curPath = path + '/' + file;
            if(fs.statSync(curPath).isDirectory()) { // recurse
                deleteFolderRecursive(curPath);
            } else { // delete file
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(path);
    }
};
function UUID(options) {
  const { noDash } = options || {};
  const dashStr = noDash ? '' : '-';
  function S4() {
    return (((1+Math.random())*0x10000)|0).toString(16).substring(1);
  }
  return (S4() + S4() + dashStr + S4() + dashStr + S4() + dashStr + S4() + dashStr + S4() + S4() + S4());
}